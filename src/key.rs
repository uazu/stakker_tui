use std::fmt;
use std::str::FromStr;

// TODO: Add any extended keys sent by xterm or rxvt or whatever

/// A keypress
///
/// Note that not all possible combinations of keys can actually be
/// transmitted as an ANSI sequence.  Often Ctrl is only recognised
/// with the 32 ASCII characters from `@` to `_`.  Some of the Meta
/// combinations can only be generated by pressing Esc quickly
/// followed by the key.
#[derive(PartialEq, Eq)]
pub enum Key {
    /// Printable character without Ctrl or Alt
    Bare(char),

    /// Control key combination.  Note that some control keys are
    /// passed through as specific values for convenience:
    /// [`Key::Tab`] for `^I` (ASCII 9), [`Key::Return`] for `^M`
    /// (ASCII 13), [`Key::Esc`] for `^[` (ASCII 27) and
    /// [`Key::BackSp`] for `^?` (ASCII 127).
    ///
    /// [`Key::BackSp`]: enum.Key.html#variant.BackSp
    /// [`Key::Esc`]: enum.Key.html#variant.Esc
    /// [`Key::Return`]: enum.Key.html#variant.Return
    /// [`Key::Tab`]: enum.Key.html#variant.Tab
    Ctrl(char),

    /// Function key, F1 to F20
    F(u32),

    Tab,
    Return,
    BackSp,
    Esc,
    Up,
    Down,
    Left,
    Right,
    PgUp,
    PgDn,
    Home,
    Insert,
    Delete,
    End,

    /// Meta/Alt key combination
    Meta(char),

    /// Meta/Alt with Ctrl key combination
    MetaCtrl(char),

    /// Meta/Alt with function key F1 to F20
    MetaF(u32),

    MetaTab,
    MetaReturn,
    MetaBackSp,
    MetaEsc,
    MetaUp,
    MetaDown,
    MetaLeft,
    MetaRight,
    MetaPgUp,
    MetaPgDn,
    MetaHome,
    MetaInsert,
    MetaDelete,
    MetaEnd,

    /// Appears before pasted text on some terminals
    PasteStart,

    /// Appears after pasted text on some terminals
    PasteEnd,

    /// `Check` can be sent in a pause in typing, 300ms after the last
    /// keypress.  It's a good time to do field validation if that
    /// validation is expensive.  See [`Terminal::check`].
    ///
    /// [`Terminal::check`]: struct.Terminal.html#method.check
    Check,

    /// `Invalid` is generated for a keypress which cannot be decoded,
    /// e.g. invalid UTF-8 or some other problem
    Invalid,
}

impl fmt::Debug for Key {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl fmt::Display for Key {
    /// Convert to a display string, using `M-` and `C-` prefixes for
    /// Meta and Ctrl.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Key::Bare(ch) => write!(f, "{}", ch),
            Key::Ctrl(ch) => write!(f, "C-{}", ch),
            Key::F(num) => write!(f, "F{}", num),
            Key::Tab => write!(f, "Tab"),
            Key::Return => write!(f, "Return"),
            Key::BackSp => write!(f, "BackSp"),
            Key::Esc => write!(f, "Esc"),
            Key::Up => write!(f, "Up"),
            Key::Down => write!(f, "Down"),
            Key::Left => write!(f, "Left"),
            Key::Right => write!(f, "Right"),
            Key::PgUp => write!(f, "PgUp"),
            Key::PgDn => write!(f, "PgDn"),
            Key::Home => write!(f, "Home"),
            Key::Insert => write!(f, "Insert"),
            Key::Delete => write!(f, "Delete"),
            Key::End => write!(f, "End"),
            Key::Meta(ch) => write!(f, "M-{}", ch),
            Key::MetaCtrl(ch) => write!(f, "M-C-{}", ch),
            Key::MetaF(num) => write!(f, "M-F{}", num),
            Key::MetaTab => write!(f, "M-Tab"),
            Key::MetaReturn => write!(f, "M-Return"),
            Key::MetaBackSp => write!(f, "M-BackSp"),
            Key::MetaEsc => write!(f, "M-Esc"),
            Key::MetaUp => write!(f, "M-Up"),
            Key::MetaDown => write!(f, "M-Down"),
            Key::MetaLeft => write!(f, "M-Left"),
            Key::MetaRight => write!(f, "M-Right"),
            Key::MetaPgUp => write!(f, "M-PgUp"),
            Key::MetaPgDn => write!(f, "M-PgDn"),
            Key::MetaHome => write!(f, "M-Home"),
            Key::MetaInsert => write!(f, "M-Insert"),
            Key::MetaDelete => write!(f, "M-Delete"),
            Key::MetaEnd => write!(f, "M-End"),
            Key::PasteStart => write!(f, "PasteStart"),
            Key::PasteEnd => write!(f, "PasteEnd"),
            Key::Check => write!(f, "Check"),
            Key::Invalid => write!(f, "Invalid"),
        }
    }
}

pub struct ParseKeyError {}

impl FromStr for Key {
    type Err = ParseKeyError;

    /// Convert back from the `Display` representation of a key
    fn from_str(mut s: &str) -> Result<Key, ParseKeyError> {
        let meta = if s.starts_with("M-") {
            s = s.split_at(2).1;
            true
        } else {
            false
        };

        let ctrl = if s.starts_with("C-") {
            s = s.split_at(2).1;
            true
        } else {
            false
        };

        let mut it = s.chars();
        if let Some(ch) = it.next() {
            if it.as_str().is_empty() {
                return Ok(match (meta, ctrl) {
                    (false, false) => Key::Bare(ch),
                    (false, true) => Key::Ctrl(ch),
                    (true, false) => Key::Meta(ch),
                    (true, true) => Key::MetaCtrl(ch),
                });
            }
            if ch == 'F' && !ctrl {
                if let Ok(v) = it.as_str().parse::<u32>() {
                    if v >= 1 && v <= 20 {
                        return Ok(if meta { Key::MetaF(v) } else { Key::F(v) });
                    }
                }
            }
        }

        if !ctrl {
            let keys = match s {
                "Return" => (Key::Return, Key::MetaReturn),
                "BackSp" => (Key::BackSp, Key::MetaBackSp),
                "Esc" => (Key::Esc, Key::MetaEsc),
                "Up" => (Key::Up, Key::MetaUp),
                "Down" => (Key::Down, Key::MetaDown),
                "Left" => (Key::Left, Key::MetaLeft),
                "Right" => (Key::Right, Key::MetaRight),
                "PgUp" => (Key::PgUp, Key::MetaPgUp),
                "PgDn" => (Key::PgDn, Key::MetaPgDn),
                "Home" => (Key::Home, Key::MetaHome),
                "Insert" => (Key::Insert, Key::MetaInsert),
                "Delete" => (Key::Delete, Key::MetaDelete),
                "End" => (Key::End, Key::MetaEnd),
                "PasteStart" if !meta => (Key::PasteStart, Key::PasteStart),
                "PasteEnd" if !meta => (Key::PasteEnd, Key::PasteEnd),
                "Check" if !meta => (Key::Check, Key::Check),
                "Invalid" if !meta => (Key::Invalid, Key::Invalid),
                _ => return Err(ParseKeyError {}),
            };
            return Ok(if meta { keys.1 } else { keys.0 });
        }

        Err(ParseKeyError {})
    }
}

// For scanning over data
struct Scan<'a> {
    data: &'a [u8],
    pos: usize,
}

impl<'a> Scan<'a> {
    fn new(data: &'a [u8]) -> Self {
        Self { data, pos: 0 }
    }
    fn grab(&mut self, v: u8) -> bool {
        if self.data.get(self.pos) == Some(&v) {
            self.pos += 1;
            true
        } else {
            false
        }
    }
    fn len(&self) -> usize {
        self.data.len() - self.pos
    }
    fn is_empty(&self) -> bool {
        self.data.len() == self.pos
    }
    //fn rest<'b>(&self, data: &'b [u8]) -> &'b [u8] {
    //    &data[self.pos..]
    //}
    fn next(&mut self) -> Option<u8> {
        if self.pos < self.data.len() {
            self.pos += 1;
            Some(self.data[self.pos - 1])
        } else {
            None
        }
    }
    fn take(&mut self, count: usize) -> Option<&'a [u8]> {
        if self.pos + count <= self.data.len() {
            self.pos += count;
            Some(&self.data[self.pos - count..self.pos])
        } else {
            None
        }
    }
    fn grab_num(&mut self) -> Option<u32> {
        let pos0 = self.pos;
        let mut val = 0;
        while self.pos < self.data.len()
            && self.data[self.pos] >= b'0'
            && self.data[self.pos] <= b'9'
        {
            val = val * 10 + u32::from(self.data[self.pos] - b'0');
            self.pos += 1;
        }
        if self.pos > pos0 {
            Some(val)
        } else {
            None
        }
    }
}

impl Key {
    /// Add meta to a key if possible, otherwise return `None`
    pub fn meta(&self) -> Option<Self> {
        match self {
            Key::Bare(ch) => Some(Key::Meta(*ch)),
            Key::Ctrl(ch) => Some(Key::MetaCtrl(*ch)),
            Key::F(num) => Some(Key::MetaF(*num)),
            Key::Tab => Some(Key::MetaTab),
            Key::Return => Some(Key::MetaReturn),
            Key::BackSp => Some(Key::MetaBackSp),
            Key::Esc => Some(Key::MetaEsc),
            Key::Up => Some(Key::MetaUp),
            Key::Down => Some(Key::MetaDown),
            Key::Left => Some(Key::MetaLeft),
            Key::Right => Some(Key::MetaRight),
            Key::PgUp => Some(Key::MetaPgUp),
            Key::PgDn => Some(Key::MetaPgDn),
            Key::Home => Some(Key::MetaHome),
            Key::Insert => Some(Key::MetaInsert),
            Key::Delete => Some(Key::MetaDelete),
            Key::End => Some(Key::MetaEnd),
            _ => None,
        }
    }

    /// Attempt to decode a keypress from data received from the
    /// terminal.  Will not decode a partial sequence at the end of
    /// the buffer unless `force` is set.  Returns count of bytes
    /// consumed and the decoded key, or else `None`.
    pub fn decode(data: &[u8], force: bool) -> Option<(usize, Key)> {
        let mut sc = Scan::new(data);
        let key = if sc.grab(27) {
            if sc.grab(27) {
                Self::decode_esc_esc(&mut sc, force)
            } else {
                Self::decode_esc(&mut sc, force)
            }
        } else {
            Self::decode_bare(&mut sc, force)
        };
        match key {
            Some(key) => Some((sc.pos, key)),
            None => None,
        }
    }

    // The expressions in these functions should either result in a
    // key (which is then wrapped in `Some`), or should execute
    // `return` directly to provide a return value.
    fn decode_bare(sc: &mut Scan<'_>, force: bool) -> Option<Key> {
        Some(match sc.next() {
            Some(c) if c < 32 => match c {
                9 => Key::Tab,
                13 => Key::Return,
                _ => Key::Ctrl((c + 64) as char),
            },
            Some(c) if c < 0x80 => match c {
                127 => Key::BackSp,
                _ => Key::Bare(c as char),
            },
            Some(c) if c < 0xC0 => Key::Invalid,
            Some(c) => {
                sc.pos -= 1;
                let len = match c >> 4 {
                    15 => 4,
                    14 => 3,
                    _ => 2,
                };
                if let Some(seq) = sc.take(len) {
                    match std::str::from_utf8(seq).ok().and_then(|s| s.chars().next()) {
                        Some(c) => Key::Bare(c),
                        None => Key::Invalid,
                    }
                } else if !force {
                    return None; // Wait for more
                } else {
                    sc.take(sc.len());
                    Key::Invalid
                }
            }
            None => return None, // Wait for more
        })
    }

    fn decode_esc(sc: &mut Scan<'_>, force: bool) -> Option<Key> {
        Some(if sc.is_empty() {
            if !force {
                return None; // Wait for more
            }
            Key::Esc
        } else if sc.grab(b'O') {
            return Self::decode_esc_o(sc, force);
        } else if sc.grab(b'[') {
            return Self::decode_esc_bracket(sc, force);
        } else {
            // Something other than 'O' or '[': See if it's Meta-(bare)
            let mark = sc.pos;
            if let Some(key) = Self::decode_bare(sc, force).and_then(|k| k.meta()) {
                key
            } else {
                sc.pos = mark;
                Key::Esc
            }
        })
    }

    fn decode_esc_o(sc: &mut Scan<'_>, force: bool) -> Option<Key> {
        let mark = sc.pos;
        Some(match sc.next() {
            Some(b'P') => Key::F(1),
            Some(b'Q') => Key::F(2),
            Some(b'R') => Key::F(3),
            Some(b'S') => Key::F(4),
            None if !force => return None, // Wait for more
            _ => {
                sc.pos = mark;
                Key::Meta('O')
            }
        })
    }

    fn decode_esc_bracket(sc: &mut Scan<'_>, force: bool) -> Option<Key> {
        let mark = sc.pos;
        Some(match sc.next() {
            Some(b'A') => Key::Up,
            Some(b'B') => Key::Down,
            Some(b'C') => Key::Right,
            Some(b'D') => Key::Left,
            Some(b'[') => match sc.next() {
                Some(b'A') => Key::F(1),
                Some(b'B') => Key::F(2),
                Some(b'C') => Key::F(3),
                Some(b'D') => Key::F(4),
                Some(b'E') => Key::F(5),
                None if !force => return None, // Wait for more
                _ => {
                    sc.pos = mark;
                    Key::Meta('[')
                }
            },
            Some(b'0'..=b'9') => {
                sc.pos -= 1;
                let num = sc.grab_num().unwrap();
                let mut _modf = None;
                if sc.grab(b';') {
                    _modf = sc.grab_num();
                    if _modf.is_none() && sc.is_empty() {
                        if !force {
                            return None; // Wait for more
                        }
                        sc.pos = mark;
                        return Some(Key::Meta('['));
                    }
                    // If there's no number there, then just
                    // ignore the spurious ';'
                }
                if sc.grab(b'~') {
                    // TODO: Take account of the modifier value `modf`?  Ignore for now
                    match num {
                        1 => Key::Home,
                        2 => Key::Insert,
                        3 => Key::Delete,
                        4 => Key::End,
                        5 => Key::PgUp,
                        6 => Key::PgDn,
                        11..=15 => Key::F(num - 10),
                        17..=21 => Key::F(num - 11),
                        23..=26 => Key::F(num - 12),
                        28..=29 => Key::F(num - 13),
                        31..=34 => Key::F(num - 14),
                        200 => Key::PasteStart,
                        201 => Key::PasteEnd,
                        _ => Key::Invalid,
                    }
                } else if sc.is_empty() && !force {
                    return None; // Wait for more
                } else {
                    // empty && force, or something other than ~
                    sc.pos = mark;
                    Key::Meta('[')
                }
            }
            None if !force => return None, // Wait for more
            _ => {
                sc.pos = mark;
                Key::Meta('[')
            }
        })
    }

    fn decode_esc_esc(sc: &mut Scan<'_>, force: bool) -> Option<Key> {
        let mark = sc.pos;
        Some(if sc.is_empty() {
            if !force {
                return None; // Wait for more
            }
            Key::MetaEsc
        } else if let Some(key) = Self::decode_esc(sc, force).and_then(|k| k.meta()) {
            key
        } else {
            sc.pos = mark;
            Key::MetaEsc
        })
    }
}
